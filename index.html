<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml"> <head> <meta charset="utf-8"> <title>North</title> <meta name="viewport" content="width=device-width"> <meta name="description" content="oAuth 1.0a server and client implementation, the successor to South."> <meta name="author" content="Nicolas Hafner &lt;shinmera@tymoon.eu&gt;"> <style type="text/css"> body{
          max-width: 1024px;
          margin: 0 auto 0 auto;
          font-family: sans-serif;
          color: #333333;
          font-size: 14pt;
          padding: 5px;
      }
      body>header{
          display:flex;
          align-items: center;
          justify-content: center;
          flex-direction: column;
          max-width: 100%;
          text-align: center;
      }
      body>header img{
          max-width: 50%;
      }
      img{
          max-width: 100%;
          max-height: 100%;
      }
      code{
          font-family: Consolas, Inconsolata, monospace;
      }
      a{
          text-decoration: none;
          color: #0055AA;
      }
      a img{
          border: none;
      }
      #documentation{
          text-align: justify;
      }
      #documentation pre{
          margin-left: 20px;
          overflow: auto;
      }
      #documentation img{
          margin: 5px;
      }
      #symbol-index>ul{
          list-style: none;
          padding: 0;
      }
      #symbol-index .package>ul{
          list-style: none;
          padding: 0 0 0 10px;
      }
      #symbol-index .package .nicknames{
          font-weight: normal;
      }
      #symbol-index .package h4{
          display: inline-block;
          margin: 0;
      }
      #symbol-index .package article{
          margin: 0 0 15px 0;
      }
      #symbol-index .package article header{
          font-size: 1.2em;
          font-weight: normal;
      }
      #symbol-index .package .name{
          margin-right: 5px;
      }
      #symbol-index .package .docstring{
          margin: 0 0 0 15px;
          white-space: pre-wrap;
          font-size: 12pt;
      }
      @media (max-width: 800px){
          body{font-size: 12pt;}
      } </style> </head> <body> <header> <h1><img alt="north" src="north-logo.png"></h1> <span class="version">1.0.0</span> <p class="description">oAuth 1.0a server and client implementation, the successor to South.</p> </header> <main> <article id="documentation">  <div><h2 id="about_north">About North</h2> <p>North is a library that implements the OAuth 1.0a consumer and provider protocols. It allows you to connect to an OAuth provider and request its resources, or to build your own OAuth provider.</p> <h2 id="how_to:_client">How To: Client</h2> <p>If you want to connect to an OAuth provider, simply instantiate a <code>client</code> and pass it the required parameters. Following the Twitter requirements and using the tokens from <a href="http://shinmera.github.io/chirp/">Chirp</a>, we end up with this:</p> <pre><code>(<a href="http://l1sp.org/cl/defvar">defvar</a> *client*
  (<a href="http://l1sp.org/cl/make-instance">make-instance</a>
   'north:client
   :key &quot;D1pMCK17gI10bQ6orBPS0w&quot;
   :secret &quot;BfkvKNRRMoBPkEtDYAAOPW4s2G9U8Z7u3KAf0dBUA&quot;
   :request-token-uri &quot;https://api.twitter.com/oauth/request_token&quot;
   :authorize-uri &quot;https://api.twitter.com/oauth/authorize&quot;
   :access-token-uri &quot;https://api.twitter.com/oauth/access_token&quot;))
</code></pre> <p>Next we start the authentication process:</p> <pre><code>(north:initiate-authentication *client*)
</code></pre> <p>Visit the returned URL and enter the verification code:</p> <pre><code>(north:complete-authentication *client* &quot;.....&quot;)
</code></pre> <p>And finally we can access some resources:</p> <pre><code>(ql:quickload :cl-json)
(<a href="http://l1sp.org/cl/defmacro">defmacro</a> with-json-decoding (() &amp;body body)
  `(<a href="http://l1sp.org/cl/let">let</a> ((drakma:*text-content-types* (<a href="http://l1sp.org/cl/list*">list*</a> '(&quot;application&quot; . &quot;json&quot;) drakma:*text-content-types*)))
     (cl-json:decode-json-from-string
      (<a href="http://l1sp.org/cl/progn">progn</a> ,@body))))

(with-json-decoding ()
  (north:make-signed-request *client* &quot;https://api.twitter.com/1.1/account/verify_credentials.json&quot; :get
                             :params '((&quot;include_entities&quot; . &quot;true&quot;))))

(with-json-decoding ()
  (north:make-signed-request *client* &quot;https://api.twitter.com/1.1/statuses/update.json&quot; :post
                             :params '((&quot;status&quot; . &quot;North and South, no matter where I look there's parens.&quot;))))
</code></pre> <p>We can also post some data:</p> <pre><code>(with-json-decoding ()
  (north:make-signed-data-request *client* &quot;https://api.twitter.com/1.1/statuses/update_with_media.json&quot;
                                  `((&quot;media[]&quot; . #p&quot;~/sweet-bear.jpg&quot;))
                                  :params '((&quot;status&quot; . &quot;Check out this sweet bear!&quot;))))
</code></pre> <p>In order to keep the access token and secret so you can resume your session without repeatedly logging in every time, you can serialise the client with <code><a href="http://l1sp.org/cl/make-load-form">make-load-form</a></code>.</p> <h2 id="how_to:_server">How To: Server</h2> <p>In order to provide a server you need to have a way of persisting two main pieces of information: applications, and sessions. The minimal amount of information necessary for an application is its key and secret. You most likely want to add additional information such as a name, icon, and description so that they can be displayed to the user when they authorise a consumer. A session needs to store quite a few pieces more: a token, token-secret, verifier token, callback, the application key, and the access rights. Default classes to contain all this information are provided through <code>application</code> and <code>session</code>.</p> <p>However, the persistence and bookkeeping of these objects is still up to your server implementations. To do this, you should subclass <code>server</code> and implement methods for <code>make-application</code>, <code>make-session</code>, <code>application</code>, <code>session</code>, <code>rehash-session</code>, <code>revoke-application</code>, <code>revoke-session</code>, <code>record-nonce</code>, and <code>find-nonce</code>. What exactly these functions should accomplish is described in their docstrings and should be fairly obvious.</p> <p>Once that is done, what's left to do is create a webservice with at least three endpoints. One for the request token, one for the authorization page, and one for the access token.</p> <h3 id="general_behaviour_for_all_endpoints">General Behaviour for All Endpoints</h3> <p>For each endpoint there exists a corresponding function to call, which will return a number of values that should be returned to the user. You can use <code>alist-&gt;oauth-response</code> to construct a properly formatted response body. The objects that you need to pass to these calls are your <code>server</code> instance and a <code>request</code> instance that encapsulates the data that the server received with the request.</p> <p>Each endpoint function performs certain checks against the request and in case of problems signals an error. Your server should intercept these and act as follows: if the error is a <code>parameter-error</code>, the HTTP response code should be <code>400</code>, and if the error is a <code>verification-error</code>, it should be <code>401</code>. Any other error is up to you. You may display information about the error in the response body, but the exact formatting thereof is up to you as well. It is however a good idea to output the same data format as your other endpoints would, aside from the oauth specific ones.</p> <h3 id="the_request_token_endpoint">The Request Token Endpoint</h3> <p>The request token endpoint should call <code>oauth/request-token</code> and return the values as <code>oauth_token</code>, <code>oauth_token_secret</code>, and <code>oauth_callback_confirmed</code> respectively.</p> <h3 id="the_authorize_endpoint">The Authorize Endpoint</h3> <p>The authorize page is special in the sense that it is not called with an oauth signed request. Instead the user calls it through a browser and the only thing it receives is the request token. The provider must then first authenticate the user and after having done so, display a page to the user that shows information about the application that they're connecting through and give them the option to either allow the application access or deny it. </p> <p>If the user selects allow, <code>oauth/authorize</code> should be called. If it returns a third value, the server should cause the user to be redirected to that URL. If not, the server should display a page that shows the second value, which is the verification token. The user must then copy this value into the consumer.</p> <p>If the user selects deny, the provider must not necessarily do anything except ensure that the <code>session</code> is revoked and thus prevent the consumer from gaining access. It is not required to notify the consumer of this in any way.</p> <h3 id="the_access_token_endpoint">The Access Token Endpoint</h3> <p>The access token endpoint should call <code>oauth/access-token</code> and return the values as <code>oauth_token</code>, and <code>oauth_token_secret</code> respectively.</p> <h3 id="protected_resource_endpoint">Protected Resource Endpoint</h3> <p>Any such endpoint should call <code>oauth/verify</code>. This function returns nothing useful and only performs checks that if failed result in an error being signalled as usual. You may additionally want to check the session for permissions to access the specific endpoint if such a distinction exists. However, such additional functionality is up to you to design.</p> <h2 id="an_example_server_/_client_setup">An Example Server / Client Setup</h2> <p>See the <a href="https://github.com/Shinmera/north/tree/master/example">north-example</a> system for a primitive, simple setup of a provider and consumer.</p> <h2 id="oauth_overview">OAuth Overview</h2> <p>OAuth is supposed to provide a relatively convenient standardised way to authenticate a user against a service (provider), and then allow the application (consumer) to access resources on the user's behalf. Key to this are two parts, the signing process, and the actual authorisation process itself.</p> <h3 id="the_authorisation_process">The Authorisation Process</h3> <p>Before an OAuth consumer can access any resources, it needs to obtain an access token. The path to this token happens in three distinct steps, during which several pieces of information need to be remembered and modified on both the consumer and provider's sides.</p> <h4 id="step_0:_generating_an_application">Step 0: Generating an Application</h4> <p>Unfortunately this is already where things begin to become awkward with the OAuth specification. The spec conflates what is essentially an application with the consumer. In order to improve clarity, North makes a distinction here. An application is a server-side instance that identifies a range of consumers. A consumer is a specific instance of a program that would like to connect to a provider through an application.</p> <p>Whatever the case may be, before you can connect at all, you need to have access to an application key and secret. These two pieces are vital in the signing and requesting process. In North, this can be done through <code>make-application</code>. Once you have an application, you can get its <code>key</code> and <code>secret</code>.</p> <h4 id="step_1:_requesting_a_request_token">Step 1: Requesting a Request Token</h4> <p>Now we actually start exchanging things with the provider as a consumer. To do this we send a signed request to the server's request-token endpoint. The request is signed using our application's secret, and we pass along the application's key as an OAuth parameter. Additionally we must give the provider a callback parameter that tells it what to do in the next step.</p> <p>The provider then verifies our signature, and if it thinks everything is proper, then it sends back a body containing a request token and request secret. From here on out our requests will need to contain the token as an OAuth parameter and be signed with the request secret along with the application secret.</p> <h4 id="step_2:_the_user_authorises_the_consumer">Step 2: The User Authorises the Consumer</h4> <p>The next step has to be done by the user themselves, such that granting access is always done through explicit consent. To do this, the consumer constructs an URL to the provider's authorize endpoint with the request token added as a GET parameter. The user then has to visit this URL.</p> <p>Once on the page, the user should be confronted with a confirmation dialog, potentially also displaying all the things the consumer could get access to, if authorised. If the user accepts, the server generates a verifier token, which is then passed back to the consumer. This happens either automatically through a redirect, if the callback was a valid URL, or through the user manually, if the callback was the string &quot;oob&quot;. In the latter case, the verifier is displayed to the user on the website, and they have to copy it into the consumer.</p> <h4 id="step_3:_requesting_an_access_token">Step 3: Requesting an Access Token</h4> <p>The final step is to exchange the request token with an access token, using the verifier that was obtained in the previous section. To do this, a fully signed request is made to the provider's access-token endpoint, which verifies the request and verifier, rehashes the consumer's token, and upgrades its access. It then returns the newly generated access token and secret that will henceforth be used to sign requests.</p> <h4 id="step_4:_accessing_resources">Step 4: Accessing Resources</h4> <p>Now that we have an access token, we can start requesting whatever resources we were permitted to. A provider may for example offer several kinds of access tokens with varying ranges of permissions. The request endpoints are of course the provider's own decision. The only thing that OAuth specifies henceforth is that the request must be fully signed.</p> <h3 id="error_handling">Error Handling</h3> <p>Now, you may notice in all this that there's no specification on how to handle errors. And you're right. The only thing OAuth says is that missing/duplicate parameters must result in an HTTP return code of 400, and an invalid signature must result in a return code of 401. Everything else, what specifically went wrong, how to fix it, or any other thing that might be useful is unspecified. Some providers do give some error information, but the format in which the error is presented is up to them.</p> <p>As such, North makes no assumptions whatsoever about how to parse the body contents on an error. You will, unfortunately, have to deal with that on your own. To do this, handle the <code>request-failed</code> error and parse the <code>body</code> of it.</p> <h3 id="the_signing_process">The Signing Process</h3> <p>Now comes the hard part. The actual signing process is unbelievably convoluted and incredibly easy to mess up. Let's start simple.</p> <h4 id="the_authorization_header">The Authorization Header</h4> <p>A signed request must contain an &quot;Authorization&quot; header, which must begin with the string &quot;OAuth &quot;. Following it are a series of oauth parameters. Each key/value pair is separated by a comma and a space, each key is separated from the value by an equals sign, and each value is surrounded by double-quotes. Each key and value must also be url-encoded. Keep in mind here that in order to transmit the request, this header is again url-encoded.</p> <h4 id="the_oauth_parameters">The OAuth Parameters</h4> <p>For each request a certain set of OAuth parameters must be present. Every request must have the <code>oauth_consumer_key</code>, <code>oauth_signature_method</code>, <code>oauth_signature</code>, <code>oauth_timestamp</code>, and <code>oauth_nonce</code>. Additional parameters are <code>oauth_callback</code>, <code>oauth_token</code>, and <code>oauth_verifier</code>, and whatever else the provider may want to require. These parameters must be ordered lexicographically by their keys and in case of duplicate keys by their values.</p> <p>The <code>oauth_consumer_key</code> is the application key that we obtained in step 0. The <code>oauth_timestamp</code> must be an integer representing the unix-time when the request was formed. The <code>oauth_nonce</code> must be a unique string for each timestamp, but must not necessarily be globally unique.</p> <h4 id="the_oauth_signature">The OAuth Signature</h4> <p>The final piece is the signature itself. The signature is created using a signing method (<code>oauth_signature_method</code>) over a signature base string, using a signature key.</p> <p>The signature key is simply the application secret, appended with an &amp;, appended with the token secret, if we have one.</p> <p>The signature base string is constructed by the uppercase representation of the request method (POST/GET) followed by an &amp;, followed by the url-encoded, normalised url, followed by an &amp;, followed by the url-encoded, concatenated parameters. </p> <h5 id="normalising_the_url">Normalising the URL</h5> <p>The URL must be normalised such that the schema is in all lowercase and the port is omitted if it is 80 and the schema is http, or if it is 443 and the schema is https.</p> <h5 id="concatenating_the_parameters">Concatenating the Parameters</h5> <p>The parameters here are all of the parameters. Namely the oauth parameters (except the signature itself), the get parameters, and the post parameters. The parameters must again be sorted as before, but now they are concatenated differently. Namely each pair is separated by an ampersand, the key is separated from the value by an equals sign, and both keys and values must be url-encoded. Note that unlike before, values must not be surrounded by double-quotes.</p> <h5 id="signing_the_token">Signing the Token</h5> <p>Potentially any signature method you might want is supported. The provider can request whatever they want. North implements the plaintext, hmac-sha1, and cmac-aes methods suggested by the spec. See the relevant hashing methods for information on how they work.</p> <h3 id="a_reminder,_just_for_fun">A Reminder, Just For Fun</h3> <p>The request is sent, url-encoded. The authorization header has url-encoded parameter values. One of those is the signature, which was constructed from a base string that has an url-encoded url part, and an url-encoded parameter part. The parameter part has url-encoded parameter values. Url-encode!</p> </div>  </article> <article id="copyright">  <h2>Copyright</h2> <span>north</span> is licensed under the <span><a href="https://tldrlegal.com/search?q=Artistic">Artistic</a></span> license.  © <span>Nicolas Hafner &lt;shinmera@tymoon.eu&gt;</span> .  This library can be obtained on <a href="https://github.com/Shinmera/north">https://github.com/Shinmera/north</a>.  </article>  </main> </body> </html> 